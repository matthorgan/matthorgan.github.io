[
    {
        "ref": "https://matthorgan.xyz/blog/powershell-handling-native-applications/",
        "title": "Handling Native Applications in PowerShell 7.3+ with $PSNativeCommandErrorActionPreference",
        "section": "blog",
        "tags": ["powershell","automation","devops"],
        "date" : "2023.02.28",
        "body": "I\u0026rsquo;ve previously written a blog post about how to handle Azure CLI errors in PowerShell. The general pattern involves redirecting any error streams to the correct place, and checking for a known exit code. There\u0026rsquo;s an exciting new feature in PowerShell from version 7.3 onwards that makes capturing errors for native applications like the Azure CLI much simpler. Enter: $PSNativeCommandErrorActionPreference\nPSNativeCommandErrorActionPreference is a preference variable that when set to true, allows for native commands to be handled in a more \u0026lsquo;PowerShell\u0026rsquo; way.\nTo enable it, you just need to set $PSNativeCommandErrorActionPreference = $true somewhere in your script, and then you can use a conventional try/catch for your error handling. Check out this before/after example:\nBefore Assign variable to output Redirect the error stream and assign to variable $err to ensure any error(s) get captured If the $LASTEXITCODE isn\u0026rsquo;t a success, throw the contents of the $err variable $err = $($podList = kubectl get pods) 2\u0026gt;\u0026amp;1 if ($LASTEXITCODE -ne 0) { throw $err } After Set the $PSNativeCommandUseErrorActionPreference to true Set $ErrorActionPreference to Stop Handle the error in a traditional try/catch and it\u0026rsquo;ll throw if there\u0026rsquo;s a non-zero exit code (Note you may still want to redirect the error stream depending on the command) $PSNativeCommandUseErrorActionPreference = $true $ErrorActionPreference = \u0026#39;Stop\u0026#39; try { $podList = kubectl get pods } catch { throw } "
    }
,
    {
        "ref": "https://matthorgan.xyz/blog/powershell-unexpected-character-error/",
        "title": "PowerShell Unexpected Character Error",
        "section": "blog",
        "tags": ["powershell","automation","azure","ci/cd","devops"],
        "date" : "2023.01.05",
        "body": "Over the years, I\u0026rsquo;ve had a few different Unexpected character encountered errors in PowerShell and for the longest time, they were always a real pain to troubleshoot and looked like a bug. Once you know the issue though, it\u0026rsquo;s a fairly simple one to solve. The latest one I\u0026rsquo;ve come across is running the following command from our CI/CD Linux build container to a Windows 2012 machine hosted in Azure:\nInvoke-AzVMRunCommand -ResourceGroupName $VMResourceGroupName -Name $VMName -CommandId 'RunPowerShellScript' -ScriptPath \u0026quot;tests/gather-vm-info.ps1\u0026quot;\nThe above command is using the Azure VM run command to run the contents of tests/gather-vm-info.ps1 on the remote Windows 2012 VM. It should be noted, I was running the exact same command on Windows 2016, and Windows 2019 VMs without any issues. The error I was seeing was the following:\nJsonReaderException: Unexpected character encountered while parsing value: W. Path \u0026#39;\u0026#39;, line 0, position 0. ArgumentException: Conversion from JSON failed with error: Unexpected character encountered while parsing value: W. Path \u0026#39;\u0026#39;, line 0, position 0. at \u0026lt;ScriptBlock\u0026gt;, /builds/golden-images/tests/gather-vm-info.ps1:49 Initially looking at this error, it felt \u0026lsquo;buggy\u0026rsquo; considering there was no \u0026lsquo;W\u0026rsquo; in my output when I ran the tests/gather-vm-info.ps1 code individually on the VM itself. I assumed it must be an issue with the Invoke-AzVMRunCommand but actually, when you look closer at the output, it\u0026rsquo;s easy to see what the issue is.\nValue[0] : Code : ComponentStatus/StdOut/succeeded Level : Info DisplayStatus : Provisioning succeeded Message : WARNING: Ping to \u0026lt;redacted URL\u0026gt; failed -- Status: TimedOut { \u0026#34;Output1\u0026#34;: true, \u0026#34;Output2\u0026#34;: true, \u0026#34;Output3\u0026#34;: true, \u0026#34;Output4\u0026#34;: true, \u0026#34;Output5\u0026#34;: false, \u0026#34;Output6\u0026#34;: true, \u0026#34;Output7\u0026#34;: true, \u0026#34;Output8\u0026#34;: false, \u0026#34;Output9\u0026#34;: false } As you can see, on investigating the Value.Message property of the object returned from Invoke-AzVMRunCommand, we\u0026rsquo;ve got a warning message at the very start of the output before our custom JSON. Suddenly, the W character in the initial error makes sense. In our scenario, Value.Message returns all output including any warning messages and therefore whilst our JSON is being returned correctly, we need to ensure that any warning messages are properly handled or suppressed to ensure that our output only returns JSON ready to be converted.\nSo, the next time you see a weird unexpected parsing error, have a look at what the starting character is. If it\u0026rsquo;s a W, there\u0026rsquo;s a good chance you could be trying to parse something that has captured one of the PowerShell output streams along with your expected output.\n"
    }
,
    {
        "ref": "https://matthorgan.xyz/blog/azcli-error-handling-in-powershell/",
        "title": "Azure CLI Error Handling in PowerShell",
        "section": "blog",
        "tags": ["powershell","automation","azcli","ci/cd","devops"],
        "date" : "2021.09.16",
        "body": "The Azure CLI (azcli) is an extremely useful tool in interacting with the Azure platform. I\u0026rsquo;ve been favouring it over the Azure PowerShell modules recently due to many of the commands being idempotent (E.g. not having to check if something already exists before trying to create can be a nice time saver). One of the downsides to using the azcli in PowerShell scripts however, is that you can\u0026rsquo;t handle errors like you would with a typical PowerShell cmdlet.\nBefore we get into the code, it\u0026rsquo;s worth saying that to filter data with the Azure CLI, you\u0026rsquo;ve got two options. Option one is to use the JMESPath query parameter e.g. in the following example az vm show --resource-group QueryDemo --name TestVM --query \u0026quot;osProfile.linuxConfiguration.ssh.publicKeys\u0026quot;. The default output from the Azure CLI is JSON and so this query is targeting a nested property publicKeys which in JSON would look something like \u0026quot;osProfile:\u0026quot; { \u0026quot;linuxConfiguration\u0026quot;: {\u0026quot;ssh\u0026quot;: { \u0026quot;publicKeys\u0026quot;: [{ \u0026quot;someData\u0026quot;: \u0026quot;someDataHere\u0026quot; }]} } }. The option I prefer however, is to use PowerShell\u0026rsquo;s ConvertFrom-Json cmdlet which brings us into our warm and cosy PowerShell world. So the same filter would be: (az vm show --resource-group QueryDemo --name TestVM | ConvertFrom-Json).osProfile.linuxConfiguration.ssh.publicKeys. I\u0026rsquo;ll be adding the ConvertFrom-Json cmdlet to the examples as this is more representitive of how I\u0026rsquo;d actually use the azcli.\nConsider the below examples with an App Registration that doesn\u0026rsquo;t exist:\ntry { $appReg = Get-AzureADApplication -ObjectId \u0026#39;NotARealObjectId\u0026#39; -ErrorAction \u0026#39;Stop\u0026#39; } catch { Write-Error \u0026#34;Uh oh, we\u0026#39;ve got an error here...\u0026#34; throw } try { $appReg = az ad app show --id \u0026#39;NotARealObjectId\u0026#39; | ConvertFrom-Json } catch { Write-Error \u0026#34;Uh oh, we\u0026#39;ve got an error here...\u0026#34; throw } In the first example, we get a lovely handled error and a custom message but in the azcli example, nothing gets thrown because the azcli is an external tool and PowerShell doesn\u0026rsquo;t natively know what to do with it.\nWe can improve things by making use of the $LASTEXITCODE which will give you the exit code of the last ran command.\n$appReg = az ad sp show --id \u0026#39;NotARealObjectId\u0026#39; | ConvertFrom-Json if ($LASTEXITCODE -ne 0) { Write-Error \u0026#34;Uh oh, we\u0026#39;ve got an error here...\u0026#34; -ErrorAction \u0026#39;Stop\u0026#39; } The above example will display our custom error message and halt the script if we get an exit code that isn\u0026rsquo;t 0. You\u0026rsquo;ll also find that the azcli spits out its own error but at the moment this isn\u0026rsquo;t information that we can capture within the constraints of our own error handling - it\u0026rsquo;ll just show the error as soon as the command isn\u0026rsquo;t successful.\nSo how do we capture the azcli error within our own error handling? We can utilise a bit of stream redirection and a subexpression to achieve a better result:\n$errOutput = $($appReg = \u0026amp; {az ad sp show --id \u0026#39;NotARealObjectId\u0026#39; | ConvertFrom-Json}) 2\u0026gt;\u0026amp;1 if ($errOutput) { Write-Error \u0026#34;Uh oh, we\u0026#39;ve got an error here...\u0026#34; -ErrorAction \u0026#39;Continue\u0026#39; throw $errOutput } In this final example, we\u0026rsquo;re executing the azcli command using the ampersand operator and capturing the variable output in the $appReg variable like before. However, this time we\u0026rsquo;re using a subexpression and redirecting the error stream of that subexpression to the success stream and capturing it in a variable called $errOutput. Now that we\u0026rsquo;ve got the error in a variable, we can display it and handle it however we like.\nOne thing to note is make sure you\u0026rsquo;re aware of what output the azcli command you\u0026rsquo;re using gives you. Some azcli commands send useful non-error commands to the error stream and therefore redirecting it like we\u0026rsquo;ve done above will trigger an error. If you wanted to, you could technically use a hybrid of the above two methods to ensure this doesn\u0026rsquo;t trip you up:\n$errOutput = $($appReg = \u0026amp; {az ad sp show --id \u0026#39;NotARealObjectId\u0026#39; | ConvertFrom-Json}) 2\u0026gt;\u0026amp;1 if ($LASTEXITCODE -ne 0) { Write-Error \u0026#34;Uh oh, we\u0026#39;ve got an error here...\u0026#34; -ErrorAction \u0026#39;Continue\u0026#39; throw $errOutput } "
    }
,
    {
        "ref": "https://matthorgan.xyz/blog/chart-testing-gitlabci-error/",
        "title": "Error using chart-testing in GitLab Pipeline",
        "section": "blog",
        "tags": ["gitlab","automation","helm","chart-testing","ci/cd","devops"],
        "date" : "2021.01.12",
        "body": "We\u0026rsquo;ve recently been moving over from Jenkins to GitLab and as part of this, I was creating a validation pipeline for our Helm charts using chart-testing. When I tried to use the tool for some basic linting using ct lint, I kept getting the error:\nError: Error linting charts: Error identifying charts to process: Error running process: exit status 128.\nHowever, when I ran ct lint --all, everything seemed to work OK and the charts were analysed as expected. Looking further into the documentation for chart-testing, if you run --all, it\u0026rsquo;ll ignore any git functionality and just analyse the charts. Without that parameter, it\u0026rsquo;ll compare with what is already in source control and only analyse the charts that have differences.\nBy default, Gitlab CI does a shallow clone which means there is no git history for the tool to look at. Unfortunately, the exit status 128 that you get back from the tool didn\u0026rsquo;t help pinpoint it but once you disable the shallow clone within GitLab CI, chart-testing will now have the git information it needs to only analyse the charts that have changed.\nFYI, to disable shallow clone in GitLab CI, add an environment variable called GIT_DEPTH and set it to 0:\nvariables: GIT_DEPTH: 0 "
    }
,
    {
        "ref": "https://matthorgan.xyz/blog/appveyor-to-github-actions/",
        "title": "Moving from AppVeyor to GitHub Actions",
        "section": "blog",
        "tags": ["appveyor","github","actions","devops","ci/cd"],
        "date" : "2020.11.26",
        "body": "It\u0026rsquo;s been over three and a half years since I first created my blog with Hugo and AppVeyor. Since then, I\u0026rsquo;ve been fortunate (or unfortunate depending on the tool!) to use lots of other CI/CD tools such as GitLab CI, Jenkins, Bamboo, Azure DevOps. GitHub Actions is one tool that I hadn\u0026rsquo;t used yet and it\u0026rsquo;s been on my radar for a while so why not take the opportunity to update the blog and the CI pipeline?\nOne of the main wins for me with GitHub Actions is the integration with GitHub. Having your code and your CI pipeline in one familiar GUI makes for a really nice experience. There\u0026rsquo;s also a great VSCode plugin I found called cschleiden.vscode-github-actions which provides a really nice view of all your pipeline builds (or workflows as they\u0026rsquo;re called in GitHub) like this:\nAnother great benefit of GitHub Actions is the marketplace that contains thousands of actions that can help automate your workflow.\nThe first thing I was going to do before I got started with GitHub Actions was to move my old inline code from the AppVeyor build file and into its own script. Over the years, I\u0026rsquo;ve realised that pipelines can get wildly out of hand if you don\u0026rsquo;t abstract as much code away from the pipeline syntax as possible. This makes your pipelines way easier to read and understand and allows for them to be easily portable into other CI tools if required.\nAfter some initial testing with the Windows 2019 runner, I decided to swap over to Linux as the builds went from around 30s in AppVeyor to a whole 3m30 in GitHub Actions.\nBefore I started to refactor my code into a little bash script, I thought I\u0026rsquo;d have a quick look at what community Actions were available to potentially simplify my workflow and lo and behold, it couldn\u0026rsquo;t have been simpler.\nThere\u0026rsquo;s a Hugo Action available from here which installs Hugo at the version you specify. On top of that, there\u0026rsquo;s a GitHub Pages Action which allows you to deploy your static content to your gh-pages branch or whichever branch your GitHub Pages is setup to point to.\nThis therefore meant that I didn\u0026rsquo;t actually need to use any scripts or any custom code at all and my workflow YAML file is wonderfully simple. My code is almost exactly the same as one of the examples in the Hugo Actions repo - everything just worked - what a joy it is to say that after the \u0026lsquo;fun\u0026rsquo; I\u0026rsquo;ve had debugging pipelines in certain CI tools in the past.\nHere\u0026rsquo;s my complete workflow to change my blog to use GitHub Actions:\nChanged my old source and master branches to main for the code and gh-pages for the static content Installed cschleiden.vscode-github-actions GitHub Actions extension in VSCode which gives you a language engine and workflow visualisation. Added .github/workflows folder to the root of the repo. Created a new file called build-site.yml. Added the new code to build my Hugo site and publish it to a gh-pages branch. Pushed the code up to GitHub and watched the CI do its thing. Here is the full workflow file with some annotations for each section:\nname: site-deployment # Tell GH Actions to only run on a push to the \u0026#39;main\u0026#39; branch on: push: branches: - main jobs: # \u0026#39;deploy\u0026#39; is the arbitrary name of our job deploy: runs-on: ubuntu-18.04 steps: # This uses the Checkout action to grab our code including the theme submodule - name: Git Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 # Installs v0.75.1 of Hugo using the Hugo Action - name: Install Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.75.1\u0026#39; # Run \u0026#39;hugo\u0026#39; to generate the static content - defaults to the ./public folder - name: Build Site run: hugo # This publishes our static site in ./public to the default gh-pages branch # GITHUB_TOKEN is an automatic token to allow authentication for Actions # We\u0026#39;ve also got a custom domain set up here - name: Deploy Site uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public cname: matthorgan.xyz As you can see from the above, this is a super simple way to get your site built and deployed on a commit. The build time for this is now ~30s which is comparable to AppVeyor but having no custom code makes it look much cleaner. I\u0026rsquo;m looking forward to getting into the weeds with GH Actions on some more complicated projects but initial impressions are very good!\n"
    }
]
